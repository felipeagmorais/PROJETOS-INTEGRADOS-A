<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador das Leis de Kepler</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 20px;
            text-align: center;
            background: linear-gradient(135deg, #0a192f 0%, #162744 100%);
            color: #e6e6e6;
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        h1 {
            font-family: 'Space Grotesk', sans-serif;
            color: #fff;
            margin-bottom: 20px;
            font-size: 2.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            letter-spacing: -0.5px;
        }
        h2 {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.5rem;
            margin: 15px 0;
            color: #64ffda;
        }
        #orbitCanvas {
            border: 2px solid rgba(100, 255, 218, 0.2);
            background: linear-gradient(180deg, #0a192f 0%, #0d1b2a 100%);
            display: block;
            margin: 1em auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            border-radius: 10px;
            width: 640px;
            height: 500px;
        }
        
        .area-info {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            margin: 10px auto;
            max-width: 580px;
            display: none; /* Inicialmente oculto */
            text-align: left;
        }
        
        .area-info table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 8px;
        }
        
        .area-info table td, .area-info table th {
            padding: 5px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .area-info h3 {
            margin: 0 0 10px 0;
            color: #ffeb3b;
        }
        
        .equal-area-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .controls {
            margin: 20px auto;
            background: rgba(255, 255, 255, 0.05);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
            max-width: 600px;
            border: 1px solid rgba(100, 255, 218, 0.1);
        }
        .controls label {
            display: block;
            margin-bottom: 10px;
            font-weight: 500;
            color: #64ffda;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .slider-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 12px;
        }
        .slider-container input[type="range"] {
            -webkit-appearance: none;
            width: 300px;
            height: 6px;
            background: rgba(100, 255, 218, 0.1);
            border-radius: 3px;
            outline: none;
        }
        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #64ffda;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .slider-container input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
        }
        .slider-value {
            min-width: 40px;
            font-weight: bold;
            color: #3498db;
        }
        button {
            background: linear-gradient(135deg, #64ffda 0%, #48ceb0 100%);
            color: #0a192f;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            font-family: 'Space Grotesk', sans-serif;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(100, 255, 218, 0.4);
            background: linear-gradient(135deg, #72ffda 0%, #48ceb0 100%);
        }
        .main-formula {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 28px;
            font-weight: 700;
            margin: 25px 0;
            padding: 20px;
            background: rgba(100, 255, 218, 0.1);
            border-radius: 12px;
            display: inline-block;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            color: #64ffda;
            border: 1px solid rgba(100, 255, 218, 0.2);
        }
        .formula-explanation {
            font-size: 16px;
            margin-bottom: 20px;
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }
        .parameters {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin: 15px auto;
            max-width: 600px;
        }
        .parameter-box {
            background: rgba(255, 255, 255, 0.05);
            border-left: 4px solid #64ffda;
            padding: 15px 20px;
            margin: 8px;
            min-width: 140px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            border-radius: 8px;
        }
        .parameter-box div:first-child {
            font-size: 0.8rem;
            color: #8892b0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .parameter-box div:last-child {
            font-family: 'Space Grotesk', sans-serif;
            font-size: 1.4rem;
            font-weight: 700;
            color: #64ffda;
            margin-top: 5px;
        }
        .legend {
            margin: 10px auto;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            font-size: 12px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px;
        }
        .legend-color {
            width: 12px;
            height: 12px;
            display: inline-block;
            margin-right: 5px;
            border-radius: 50%;
        }
        .navigation {
            margin-top: 20px;
            padding: 15px;
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0,0,0,0.1);
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }
        .two-column {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            margin: 0 auto;
            max-width: 1400px;
            gap: 30px;
        }
        .simulator {
            flex: 3; /* Proporção maior para o simulador */
            min-width: 350px;
            padding: 10px;
        }
        .info {
            flex: 2; /* Proporção menor para a informação */
            min-width: 450px;
            padding: 20px 30px; /* Aumenta o padding à esquerda */
            text-align: left;
            border-left: 1px solid rgba(100, 255, 218, 0.1); /* Adiciona uma linha separadora */
            overflow-y: visible; /* Remove o scroll */
            max-height: none; /* Remove o limite de altura */
        }
        
        /* Media query para ajustar em telas menores */
        @media (max-width: 900px) {
            .two-column {
                flex-direction: column;
            }
            .simulator, .info {
                width: 100%;
                max-height: none; /* Remove a altura máxima em telas pequenas */
            }
            .info {
                border-left: none;
                border-top: 1px solid #e0e0e0;
                margin-top: 20px;
                padding-top: 20px;
            }
        }
        
        /* Certifica-se de que o canvas tem tamanho responsivo */
        #orbitCanvas {
            max-width: 100%;
            height: auto;
        }
        .key-points {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid rgba(100, 255, 218, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .key-points ul {
            text-align: left;
            padding-left: 20px;
            color: #e6e6e6;
            margin: 10px 0;
        }
        
        .key-points li {
            margin-bottom: 6px;
            font-size: 0.95rem;
        }
        
        .law-section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 4px solid #64ffda;
            backdrop-filter: blur(10px);
            font-size: 0.95rem;
            line-height: 1.5;
        }
        
        .law-title {
            color: #64ffda;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.3rem;
            font-family: 'Space Grotesk', sans-serif;
        }
        
        .tab-container {
            display: flex;
            border-bottom: 1px solid rgba(100, 255, 218, 0.2);
            margin-bottom: 15px;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(100, 255, 218, 0.1);
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
            color: #e6e6e6;
            transition: all 0.3s ease;
        }
        
        .tab:hover {
            background: rgba(100, 255, 218, 0.1);
        }
        
        .tab.active {
            background: rgba(100, 255, 218, 0.2);
            color: #64ffda;
            font-weight: bold;
            border-color: rgba(100, 255, 218, 0.3);
        }
        
        .info {
            flex: 2;
            min-width: 300px;
            padding: 10px 20px 10px 30px;
            text-align: left;
            border-left: 1px solid rgba(100, 255, 218, 0.1);
            overflow-y: auto;
            max-height: 750px;
            color: #e6e6e6;
        }
        .tab-content {
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .tab-content.active {
            display: block;
            opacity: 1;
        }
        
        .info {
            flex: 2;
            min-width: 300px;
            padding: 10px 20px 10px 30px;
            text-align: left;
            border-left: 1px solid rgba(100, 255, 218, 0.1);
            overflow-y: auto;
            max-height: 750px;
            color: #e6e6e6;
        }
        
        .tab-container {
            position: sticky;
            top: 0;
            background: #0a192f;
            padding: 10px 0;
            z-index: 10;
            border-bottom: 1px solid rgba(100, 255, 218, 0.2);
        }
        
        .tab {
            position: relative;
            padding: 10px 20px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(100, 255, 218, 0.1);
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
            color: #e6e6e6;
            transition: all 0.3s ease;
        }
        
        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 0;
            right: 0;
            height: 2px;
            background: #64ffda;
        }
        
        .law-image {
            width: 100%;
            max-width: 200px;
            margin: 10px auto;
        }

        /* Scroll suave */
        html {
            scroll-behavior: smooth;
        }

        /* Estilo do Footer */
        .footer {
            margin-top: auto;
            padding: 2rem;
            background: rgba(10, 25, 47, 0.95);
            border-top: 1px solid rgba(100, 255, 218, 0.1);
        }

        .credits {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
        }

        .credits h3 {
            color: #64ffda;
            font-family: 'Space Grotesk', sans-serif;
            margin-bottom: 1rem;
        }

        .credits-content {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 2rem;
            margin-bottom: 1rem;
        }

        .credit-item {
            flex: 1;
            min-width: 250px;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            border: 1px solid rgba(100, 255, 218, 0.1);
        }

        .credit-item h4 {
            color: #64ffda;
            margin: 0 0 0.5rem 0;
        }

        .credit-item p {
            margin: 0;
            font-size: 0.9rem;
            color: #8892b0;
        }

        .credit-item a {
            color: #64ffda;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        .credit-item a:hover {
            color: #72ffda;
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <h1>Simulador das Leis de Kepler</h1>
    
    <div class="main-formula">
        T² = a³
    </div>
    <div class="formula-explanation">
        O quadrado do período (T) é igual ao cubo do semi-eixo maior (a)
    </div>
    
    <div class="two-column">
        <div class="simulator">
            <div class="controls">
                <label for="axis">Semi-eixo maior (U.A.):</label>
                <div class="slider-container">
                    <span>0.5</span>
                    <input id="axis" type="range" min="0.5" max="5" value="1" step="0.1">
                    <span>5.0</span>
                    <span class="slider-value" id="axisValue">1.0</span>
                </div>
                
                <label for="eccentricity">Excentricidade:</label>
                <div class="slider-container">
                    <span>0</span>
                    <input id="eccentricity" type="range" min="0" max="0.9" value="0.5" step="0.1">
                    <span>0.9</span>
                    <span class="slider-value" id="eccentricityValue">0.5</span>
                </div>
                
                <button id="resetButton">Resetar</button>
            </div>
            
            <div class="parameters">
                <div class="parameter-box">
                    <div>Semi-eixo maior:</div>
                    <div id="axisOutput">1.0 UA</div>
                </div>
                <div class="parameter-box">
                    <div>Período orbital:</div>
                    <div id="periodOutput">1.0 anos</div>
                </div>
            </div>
            
            <canvas id="orbitCanvas" width="800" height="500"></canvas>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: yellow;"></div>
                    <div>Sol</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #3498db;"></div>
                    <div>Planeta</div>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: red;"></div>
                    <div>Outro foco</div>
                </div>
            </div>
        </div>
        
        <div class="info">
            <div class="tab-container">
                <div class="tab active" onclick="changeTab(event, 'overview')">Visão Geral</div>
                <div class="tab" onclick="changeTab(event, 'first-law')">1ª Lei</div>
                <div class="tab" onclick="changeTab(event, 'second-law')">2ª Lei</div>
                <div class="tab" onclick="changeTab(event, 'third-law')">3ª Lei</div>
            </div>
            
            <div id="overview" class="tab-content active">
                <h2>As Leis de Kepler</h2>
                <p>Johannes Kepler (1571-1630) formulou três importantes leis que descrevem o movimento dos planetas ao redor do Sol:</p>
                
                <div class="key-points">
                    <ul>
                        <li><strong>1ª Lei (Lei das órbitas elípticas)</strong>: Os planetas se movem em órbitas elípticas com o Sol em um dos focos.</li>
                        <li><strong>2ª Lei (Lei das áreas)</strong>: Uma linha ligando o planeta ao Sol varre áreas iguais em tempos iguais.</li>
                        <li><strong>3ª Lei (Lei harmônica)</strong>: O quadrado do período orbital é diretamente proporcional ao cubo do semi-eixo maior da órbita.</li>
                    </ul>
                </div>
                
                <p>Use os controles deslizantes para explorar como:</p>
                <ul>
                    <li>O tamanho da órbita (semi-eixo maior) afeta o período orbital</li>
                    <li>A excentricidade muda a forma da órbita</li>
                    <li>A velocidade do planeta varia ao longo da órbita</li>
                </ul>
                
                <div class="parameter-box" style="margin-top: 20px; width: auto;">
                    <div>Excentricidade atual:</div>
                    <div id="eccentricityOutput">0.5</div>
                </div>
            </div>
            
            <div id="first-law" class="tab-content">
                <div class="law-section">
                    <h3 class="law-title">Primeira Lei de Kepler - Lei das Órbitas Elípticas</h3>
                    <p>"Os planetas se movem em órbitas elípticas com o Sol em um dos focos."</p>
                    
                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Kepler-first-law.svg/300px-Kepler-first-law.svg.png" 
                         alt="Primeira Lei de Kepler" class="law-image">
                    
                    <p>Conceitos importantes:</p>
                    <ul>
                        <li><strong>Elipse</strong>: figura geométrica oval fechada com dois pontos focais</li>
                        <li><strong>Focos</strong>: dois pontos fixos dentro da elipse</li>
                        <li><strong>Excentricidade</strong>: medida da "ovalidade" da órbita (0 = círculo perfeito)</li>
                    </ul>
                    
                    <p>Esta lei contradiz o modelo geocêntrico anterior que propunha órbitas circulares perfeitas. Experimente aumentar a excentricidade no simulador para ver como a órbita se torna mais elíptica!</p>
                </div>
            </div>
            
            <div id="second-law" class="tab-content">
                <div class="law-section">
                    <h3 class="law-title">Segunda Lei de Kepler - Lei das Áreas Iguais</h3>
                    <p>"Uma linha ligando um planeta ao Sol varre áreas iguais em tempos iguais."</p>
                    
                    <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a8/Kepler-second-law.svg/300px-Kepler-second-law.svg.png" 
                         alt="Segunda Lei de Kepler" class="law-image">
                    
                    <p>Isto significa que:</p>
                    <ul>
                        <li>O planeta se move mais <strong>rápido</strong> quando está mais <strong>próximo</strong> do Sol</li>
                        <li>O planeta se move mais <strong>devagar</strong> quando está mais <strong>distante</strong> do Sol</li>
                        <li>Esta lei descreve a <strong>conservação do momento angular</strong> do planeta</li>
                    </ul>
                    
                    <p>Observe no simulador como a velocidade do planeta (indicada pelo número e pela cauda) aumenta quando ele está mais próximo do Sol.</p>
                </div>
            </div>
            
            <div id="third-law" class="tab-content">
                <div class="law-section">
                    <h3 class="law-title">Terceira Lei de Kepler - Lei Harmônica</h3>
                    <p>"O quadrado do período orbital é proporcional ao cubo do semi-eixo maior da órbita."</p>
                    
                    <div class="main-formula" style="font-size: 18px; text-align: center;">
                        T² = a³
                    </div>
                    
                    <p>Onde:</p>
                    <ul>
                        <li><strong>T</strong> é o período orbital (tempo para completar uma volta)</li>
                        <li><strong>a</strong> é o semi-eixo maior (metade do eixo maior da elipse)</li>
                    </ul>
                    
                    <p>Implicações importantes:</p>
                    <ul>
                        <li>Planetas mais distantes do Sol têm períodos orbitais mais longos</li>
                        <li>Esta relação matemática precisa permite prever períodos orbitais</li>
                        <li>A lei se aplica a qualquer sistema onde um corpo orbita outro muito mais massivo</li>
                    </ul>
                    
                    <p>Experimente aumentar o semi-eixo maior no simulador e observe como o período orbital aumenta!</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Adicionar um div para mostrar informações das áreas fora do canvas -->
    <div class="area-info" id="areaInfo">
        <h3>Demonstração da Segunda Lei de Kepler</h3>
        <p>As áreas dos setores são <strong>iguais</strong> para tempos iguais, independente da posição na órbita.</p>
        <table id="areaMeasurements">
            <tr>
                <th>Setor</th>
                <th>Área (u²)</th>
                <th>Tempo (s)</th>
                <th>Velocidade</th>
            </tr>
        </table>
    </div>

    <script>
        let animationId;
        const axisSlider = document.getElementById('axis');
        const eccentricitySlider = document.getElementById('eccentricity');
        const axisValue = document.getElementById('axisValue');
        const eccentricityValue = document.getElementById('eccentricityValue');
        const resetButton = document.getElementById('resetButton');
        let showSecondLaw = false; // Flag para mostrar a visualização da segunda lei
        const fixedTimeInterval = 1000; // Intervalo fixo de 1 segundo para os setores
        let nextSectorTime = Date.now();  // Adicionar esta linha
        let sectorPoints = [];
        let lastSampleTime = Date.now();
        let scaledA, scaledB; // Adicionar estas variáveis globalmente
        
        // Função para mudar de guia
        function changeTab(event, tabId) {
            // Ocultar todos os conteúdos das guias
            const tabContents = document.getElementsByClassName('tab-content');
            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].classList.remove('active');
            }
            
            // Remover a classe active de todas as guias
            const tabs = document.getElementsByClassName('tab');
            for (let i = 0; i < tabs.length; i++) {
                tabs[i].classList.remove('active');
            }
            
            // Mostrar o conteúdo da guia clicada e destacar a guia
            document.getElementById(tabId).classList.add('active');
            event.currentTarget.classList.add('active');
            
            // Atualizar a flag para mostrar a visualização da segunda lei
            showSecondLaw = (tabId === 'second-law');
            
            // Mostrar ou ocultar a área de informações
            document.getElementById('areaInfo').style.display = showSecondLaw ? 'block' : 'none';
            
            // Resetar os pontos dos setores e o tempo
            sectorPoints = [];
            nextSectorTime = Date.now();  // Atualizar nextSectorTime ao mudar de tab
            
            // Não é necessário reiniciar a simulação, apenas limpar os pontos
            if (showSecondLaw) {
                // Atualizar a tabela de áreas
                updateAreaTable();
            }
        }
        
        // Gerar estrelas aleatórias para o fundo
        const stars = [];
        function generateStars(count) {
            const canvas = document.getElementById('orbitCanvas');
            stars.length = 0;  // Limpar estrelas anteriores
            
            for (let i = 0; i < count; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.5 + 0.5,
                    opacity: Math.random() * 0.8 + 0.2
                });
            }
        }
        
        // Atualiza os valores exibidos quando os sliders são movidos
        axisSlider.addEventListener('input', function() {
            axisValue.textContent = parseFloat(this.value).toFixed(1);
            startSimulation(); // Atualiza em tempo real
        });
        
        eccentricitySlider.addEventListener('input', function() {
            eccentricityValue.textContent = parseFloat(this.value).toFixed(1);
            startSimulation(); // Atualiza em tempo real
        });
        
        // Adicionar evento para o botão de reset
        resetButton.addEventListener('click', function() {
            axisSlider.value = 1;
            eccentricitySlider.value = 0.5;
            axisValue.textContent = "1.0";
            eccentricityValue.textContent = "0.5";
            startSimulation();
        });
        
        function startSimulation() {
            const a = parseFloat(document.getElementById('axis').value);
            const e = parseFloat(document.getElementById('eccentricity').value);
            const T = Math.sqrt(a ** 3);
            
            document.getElementById('axisOutput').innerText = a.toFixed(1) + " UA";
            document.getElementById('eccentricityOutput').innerText = e.toFixed(1);
            document.getElementById('periodOutput').innerText = T.toFixed(2) + " anos";
            
            cancelAnimationFrame(animationId);
            animateOrbit(a, e, T);
        }

        function animateOrbit(a, e, T) {
            let lastSectorTime = 0; // Adicionar esta variável para controlar o tempo do último setor

            const canvas = document.getElementById('orbitCanvas');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Cálculo dos parâmetros da órbita elíptica
            const b = a * Math.sqrt(1 - e * e); // Semi-eixo menor
            const c = a * e; // Distância do centro ao foco
            
            // Escala para visualização
            const scale = 60;
            const scaledA = a * scale;
            const scaledB = b * scale;
            const scaledC = c * scale;
            
            // Posicionar a estrela em um dos focos, garantindo que o centro da elipse esteja no centro do canvas
            const starX = centerX - scaledC;
            const starY = centerY;
            
            // Configurar o movimento em coordenadas polares
            let trueAnomaly = 0;
            const baseSpeed = (2 * Math.PI) / (T * 40); // Alterado de 100 para 60 para aumentar a velocidade
            
            // Armazenar o caminho da órbita - com centro da elipse no centro do canvas
            const orbitPath = [];
            for (let theta = 0; theta < 2 * Math.PI; theta += 0.01) {
                // Coordenadas em relação ao centro da elipse
                const x = centerX + scaledA * Math.cos(theta);
                const y = centerY + scaledB * Math.sin(theta);
                orbitPath.push({x, y});
            }

            // Variáveis para demonstração da segunda lei
            let lastSampleTime = Date.now();
            const maxSectors = 3; // Número de setores a serem mostrados
            
            // Calcular uma área fixa para todos os setores (baseada na área total da elipse)
            const totalEllipseArea = Math.PI * scaledA * scaledB;
            const fixedSectorArea = totalEllipseArea / 12; // Dividir em 12 setores (30 graus cada)
            
            // Função para calcular a anomalia verdadeira a partir da anomalia excêntrica
            function trueAnomalyFromE(E) {
                return 2 * Math.atan(Math.sqrt((1+e)/(1-e)) * Math.tan(E/2));
            }
            
            // Função para calcular a anomalia excêntrica a partir da anomalia média (equação de Kepler)
            function eccentricAnomaly(M) {
                // Resolver a equação de Kepler iterativamente
                let E = M; // Valor inicial
                let delta = 1;
                let iterations = 0;
                
                while (Math.abs(delta) > 1e-6 && iterations < 20) {
                    delta = (E - e * Math.sin(E) - M) / (1 - e * Math.cos(E));
                    E = E - delta;
                    iterations++;
                }
                
                return E;
            }
            
            // Função para calcular o ângulo necessário para varrer uma área específica a partir de um ângulo inicial
            function calculateAngleForArea(startAngle, targetArea) {
                // Para simplificação, usamos a área do setor e a relação entre ângulo e área na elipse
                // A área de um setor elíptico é proporcional ao ângulo varrido
                const totalArea = Math.PI * scaledA * scaledB;  // Área total da elipse
                const angleForTargetArea = (targetArea / totalArea) * 2 * Math.PI;  // Proporção da área total
                
                return (startAngle + angleForTargetArea) % (2 * Math.PI);
            }

            let fixedTimeInterval = 3000; // Alterado para 3 segundos

            function drawFrame() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Desenhar as estrelas no plano de fundo
                for (const star of stars) {
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.radius, 0, 2 * Math.PI);
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                    ctx.fill();
                }
                
                // Desenhar a órbita completa
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                for (let i = 0; i < orbitPath.length; i++) {
                    if (i === 0) {
                        ctx.moveTo(orbitPath[i].x, orbitPath[i].y);
                    } else {
                        ctx.lineTo(orbitPath[i].x, orbitPath[i].y);
                    }
                }
                ctx.closePath();
                ctx.stroke();
                
                // Desenhar o centro da elipse
                ctx.beginPath();
                ctx.arc(centerX, centerY, 2, 0, 2 * Math.PI);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fill();
                
                // Desenhar os focos
                // Sol em um dos focos
                ctx.beginPath();
                ctx.arc(starX, starY, 8, 0, 2 * Math.PI);
                ctx.fillStyle = 'yellow';
                ctx.fill();
                
                // Brilho ao redor da estrela
                const gradient = ctx.createRadialGradient(
                    starX, starY, 8,
                    starX, starY, 16
                );
                gradient.addColorStop(0, 'rgba(255, 255, 150, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 255, 150, 0)');
                ctx.beginPath();
                ctx.arc(starX, starY, 16, 0, 2 * Math.PI);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Outro foco
                ctx.beginPath();
                ctx.arc(centerX + scaledC, centerY, 3, 0, 2 * Math.PI);
                ctx.fillStyle = 'red';
                ctx.fill();
                
                // Desenhar os eixos
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.setLineDash([5, 3]);
                // Semi-eixo maior
                ctx.moveTo(centerX - scaledA, centerY);
                ctx.lineTo(centerX + scaledA, centerY);
                // Semi-eixo menor
                ctx.moveTo(centerX, centerY - scaledB);
                ctx.lineTo(centerX, centerY + scaledB);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Calcular posição do planeta usando equação paramétrica da elipse
                // Usando o ângulo em relação ao centro da elipse (não ao foco)
                const x = centerX + scaledA * Math.cos(trueAnomaly);
                const y = centerY + scaledB * Math.sin(trueAnomaly);
                
                // Demonstração da Segunda Lei de Kepler (áreas iguais em tempos iguais)
                if (showSecondLaw) {
                    const currentTime = Date.now();
                    
                    if (currentTime >= nextSectorTime && sectorPoints.length < 2) {
                        // Limpar conteúdo se for o primeiro ponto
                        if (sectorPoints.length === 0) {
                            const areaInfoDiv = document.getElementById('areaInfo');
                            areaInfoDiv.innerHTML = `
                                <h3>Demonstração da Segunda Lei de Kepler</h3>
                                <p>As áreas dos setores são <strong>iguais</strong> para tempos iguais, independente da posição na órbita.</p>
                            `;
                        }
                        
                        // Calcular e mostrar informações se já tivermos um ponto anterior
                        if (sectorPoints.length > 0) {
                            const prevPoint = sectorPoints[sectorPoints.length - 1];
                            const area = calculateSectorArea(
                                prevPoint.x, prevPoint.y,
                                x, y,
                                starX, starY,
                                scaledA, scaledB,
                                prevPoint.angle, trueAnomaly
                            );
                            
                            const elapsedTime = (currentTime - prevPoint.startTime) / 1000;
                            const velocityMedia = area / elapsedTime;
                            
                            const areaInfoDiv = document.getElementById('areaInfo');
                            const sectorColors = ["#FFB74D", "#64B5F6", "#F06292"];
                            const sectorIndex = sectorPoints.length - 1;
                            
                            const sectorInfo = `
                                <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                    <div style="display: flex; align-items: center;">
                                        <div style="width: 12px; height: 12px; background: ${sectorColors[sectorIndex]}; border-radius: 50%; margin-right: 10px;"></div>
                                        <strong>Setor ${sectorIndex + 1}</strong>
                                    </div>
                                    <div style="margin-left: 22px;">
                                        <div>Área: ${area.toFixed(0)} u²</div>
                                        <div>Tempo: ${elapsedTime.toFixed(1)} s</div>
                                        <div>Velocidade média: ${velocityMedia.toFixed(1)} u²/s</div>
                                    </div>
                                </div>`;
                            
                            const infoContainer = document.createElement('div');
                            infoContainer.innerHTML = sectorInfo;
                            areaInfoDiv.appendChild(infoContainer);
                        }
                        
                        // Adicionar novo ponto
                        sectorPoints.push({
                            x: x,
                            y: y,
                            angle: trueAnomaly,
                            startTime: currentTime
                        });
                        
                        if (sectorPoints.length === 2) {
                            lastSectorTime = Date.now(); // Marcar o momento em que o segundo setor foi criado
                        }
                        
                        nextSectorTime = currentTime + fixedTimeInterval;
                    }
                }
                
                // Limpar os setores após completar o ciclo
                if (showSecondLaw && sectorPoints.length >= 3 && Date.now() > nextSectorTime + fixedTimeInterval) {
                    sectorPoints = [];
                    nextSectorTime = Date.now();
                    const areaInfoDiv = document.getElementById('areaInfo');
                    areaInfoDiv.innerHTML = `
                        <h3>Demonstração da Segunda Lei de Kepler</h3>
                        <p>As áreas dos setores são <strong>iguais</strong> para tempos iguais, independente da posição na órbita.</p>
                    `;
                }

                // Desenhar o planeta
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                ctx.fillStyle = '#3498db';
                ctx.fill();
                
                // Resetar os pontos após completar 3 setores e um intervalo adicional
                if (showSecondLaw && sectorPoints.length >= 3 && Date.now() > nextSectorTime + fixedTimeInterval) {
                    sectorPoints = [];
                    nextSectorTime = Date.now();
                }

                // Calcular distância do planeta ao sol para a velocidade
                const distanceFromSun = Math.sqrt(Math.pow(x - starX, 2) + Math.pow(y - starY, 2));
                const maxDistance = scaledA + scaledC; // Maior distância possível
                const minDistance = scaledA - scaledC; // Menor distância possível
                
                // Normalizar a velocidade baseada na distância (Segunda Lei de Kepler)
                const speedFactor = minDistance / distanceFromSun;
                const angularSpeed = baseSpeed * speedFactor;
                
                // Desenhar uma pequena cauda para mostrar o movimento
                const prevAnomaly = trueAnomaly - angularSpeed * 0.5;
                const prevX = centerX + scaledA * Math.cos(prevAnomaly);
                const prevY = centerY + scaledB * Math.sin(prevAnomaly);
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(prevX, prevY);
                ctx.strokeStyle = 'rgba(52, 152, 219, 0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Adicionar indicação visual de velocidade
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.font = '12px Arial';
                const speed = speedFactor;
                const speedText = `${speed.toFixed(1)}x`;
                ctx.fillText(speedText, x + 10, y - 10);

                trueAnomaly += angularSpeed;
                if (trueAnomaly >= 2 * Math.PI) {
                    trueAnomaly = 0;
                }
                
                // Calcular e armazenar áreas quando estivermos mostrando a segunda lei
                if (showSecondLaw) {
                    const currentTime = Date.now();
                    
                    if (currentTime >= nextSectorTime && sectorPoints.length < 3) {
                        // Calcular a área do setor se já tivermos um ponto anterior
                        if (sectorPoints.length > 0) {
                            const prevPoint = sectorPoints[sectorPoints.length - 1];
                            const area = calculateSectorArea(
                                prevPoint.x, prevPoint.y,
                                x, y,
                                starX, starY,
                                scaledA, scaledB,
                                prevPoint.angle, trueAnomaly
                            );
                            
                            // Atualizar o elemento HTML com as informações do setor
                            const areaInfoDiv = document.getElementById('areaInfo');
                            const sectorColors = ["#FFB74D", "#64B5F6", "#F06292"];
                            const sectorIndex = sectorPoints.length - 1;
                            
                            const elapsedTime = (currentTime - prevPoint.startTime) / 1000; // Tempo em segundos
                            const velocityMedia = area / elapsedTime;
                            
                            // Criar uma string formatada com as informações
                            const sectorInfo = `
                                <div style="margin: 10px 0; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 5px;">
                                    <div style="display: flex; align-items: center;">
                                        <div style="width: 12px; height: 12px; background: ${sectorColors[sectorIndex]}; border-radius: 50%; margin-right: 10px;"></div>
                                        <strong>Setor ${sectorIndex + 1}</strong>
                                    </div>
                                    <div style="margin-left: 22px;">
                                        <div>Área: ${area.toFixed(0)} u²</div>
                                        <div>Tempo: ${elapsedTime.toFixed(1)} s</div>
                                        <div>Velocidade média: ${velocityMedia.toFixed(1)} u²/s</div>
                                    </div>
                                </div>`;
                            
                            // Limpar conteúdo anterior se for o primeiro setor
                            if (sectorIndex === 0) {
                                areaInfoDiv.innerHTML = `
                                    <h3>Demonstração da Segunda Lei de Kepler</h3>
                                    <p>As áreas dos setores são <strong>iguais</strong> para tempos iguais, independente da posição na órbita.</p>
                                `;
                            }
                            
                            // Adicionar as informações ao painel
                            const infoContainer = document.createElement('div');
                            infoContainer.innerHTML = sectorInfo;
                            areaInfoDiv.appendChild(infoContainer);
                        }
                        
                        sectorPoints.push({
                            x: x,
                            y: y,
                            angle: trueAnomaly % (2 * Math.PI), // Garantir que o ângulo está em radianos e normalizado
                            startTime: currentTime
                        });
                        
                        nextSectorTime = currentTime + fixedTimeInterval;
                    }
                }

                // Desenhar os setores existentes
                if (showSecondLaw) {
                    for (let i = 0; i < sectorPoints.length - 1; i++) {
                        const startPoint = sectorPoints[i];
                        const endPoint = sectorPoints[i + 1];
                        const sectorColors = ["#FFB74D", "#64B5F6", "#F06292"];
                        
                        // Desenhar o setor elíptico
                        ctx.beginPath();
                        ctx.moveTo(starX, starY);
                        ctx.lineTo(startPoint.x, startPoint.y);
                        
                        // Desenhar o arco elíptico
                        let startAngle = startPoint.angle;
                        let endAngle = endPoint.angle;
                        if (endAngle < startAngle) endAngle += 2 * Math.PI;
                        
                        ctx.ellipse(
                            centerX, centerY,
                            scaledA, scaledB,
                            0,
                            startAngle,
                            endAngle
                        );
                        
                        ctx.lineTo(starX, starY);
                        ctx.fillStyle = sectorColors[i] + '4D'; // Adiciona 30% de transparência
                        ctx.fill();
                        ctx.strokeStyle = sectorColors[i];
                        ctx.stroke();
                    }
                }

                // Remover o código duplicado de reset e manter apenas uma verificação
                if (showSecondLaw && sectorPoints.length === 2 && Date.now() > lastSectorTime + 8000) {
                    sectorPoints = [];
                    nextSectorTime = Date.now();
                    lastSectorTime = 0;
                    const areaInfoDiv = document.getElementById('areaInfo');
                    areaInfoDiv.innerHTML = `
                        <h3>Demonstração da Segunda Lei de Kepler</h3>
                        <p>As áreas dos setores são <strong>iguais</strong> para tempos iguais, independente da posição na órbita.</p>
                    `;
                }

                animationId = requestAnimationFrame(drawFrame);
            }
            
            // Função para calcular a área do setor elíptico
            function calculateSectorArea(x1, y1, x2, y2, fx, fy, a, b, angle1, angle2) {
                // Normalizar os ângulos para garantir que angle2 > angle1
                while (angle2 < angle1) angle2 += 2 * Math.PI;
                
                // Usar a fórmula correta para área do setor elíptico
                // A = (ab/2) * (theta - e*sin(theta))
                // onde theta é o ângulo entre os pontos
                // e e é a excentricidade
                const e = Math.sqrt(1 - (b*b)/(a*a)); // excentricidade
                const deltaTheta = angle2 - angle1;
                const area = (a * b / 2) * (deltaTheta - e * (Math.sin(angle2) - Math.sin(angle1)));
                
                return Math.abs(area);
            }
            
            // Função para interpolar pontos entre dois pontos da órbita
            function interpolatePoints(p1, p2, t) {
                return {
                    x: p1.x + (p2.x - p1.x) * t,
                    y: p1.y + (p2.y - p1.y) * t,
                    angle: p1.angle + (p2.angle - p1.angle) * t
                };
            }

            // Função melhorada para calcular a área do setor elíptico usando radianos
            function calculateSectorArea(x1, y1, x2, y2, fx, fy, a, b, angle1, angle2) {
                // Garantir precisão double e conversão para radianos
                angle1 = Number(angle1) % (2 * Math.PI);
                angle2 = Number(angle2) % (2 * Math.PI);
                a = Number(a);
                b = Number(b);
                
                // Normalizar ângulos mantendo-os em radianos
                if (angle2 < angle1) {
                    angle2 += 2.0 * Math.PI;
                }
                
                // Método de Simpson com mais pontos de integração
                const n = 100; // Aumentado para maior precisão
                const h = (angle2 - angle1) / n;
                let sum = 0.0;
                
                for (let i = 0; i <= n; i++) {
                    const theta = angle1 + i * h;
                    // Calcular o raio usando a equação paramétrica da elipse
                    const r = (a * b) / Math.sqrt(
                        Math.pow(b * Math.cos(theta), 2.0) + 
                        Math.pow(a * Math.sin(theta), 2.0)
                    );
                    
                    // Aplicar a regra de Simpson com coeficientes precisos
                    const coef = (i === 0 || i === n) ? 1.0 : (i % 2 === 0 ? 2.0 : 4.0);
                    sum += coef * 0.5 * r * r;
                }
                
                // Calcular a área final
                const area = Math.abs((h / 3.0) * sum);
                return area;
            }

            // Modificar a parte que calcula e mostra os setores
            if (showSecondLaw) {
                const currentTime = Date.now();
                const samplingRate = 60; // 60 Hz de amostragem
                const numInterpolations = 5; // Pontos interpolados entre cada par de pontos
                
                if (currentTime >= nextSectorTime && sectorPoints.length < 3) {
                    if (sectorPoints.length > 0) {
                        const prevPoint = sectorPoints[sectorPoints.length - 1];
                        let totalArea = 0.0;
                        
                        // Calcular área usando pontos interpolados
                        for (let i = 0; i < numInterpolations; i++) {
                            const t1 = i / numInterpolations;
                            const t2 = (i + 1) / numInterpolations;
                            const p1 = interpolatePoints(prevPoint, {x, y, angle: trueAnomaly}, t1);
                            const p2 = interpolatePoints(prevPoint, {x, y, angle: trueAnomaly}, t2);
                            
                            totalArea += calculateSectorArea(
                                p1.x, p1.y,
                                p2.x, p2.y,
                                starX, starY,
                                scaledA, scaledB,
                                p1.angle, p2.angle
                            );
                        }
                        
                        // Atualizar display com maior precisão
                        const elapsedTime = (currentTime - prevPoint.startTime) / 1000.0;
                        const velocityMedia = totalArea / elapsedTime;
                        
                        updateSectorInfo(totalArea, elapsedTime, velocityMedia, sectorPoints.length - 1);
                    }
                    
                    // Armazenar com maior precisão
                    sectorPoints.push({
                        x: Number(x),
                        y: Number(y),
                        angle: Number(trueAnomaly),
                        startTime: Number(currentTime)
                    });
                }
            }
            
            drawFrame();
        }
        
        // Função para atualizar a tabela de informações das áreas
        function updateAreaTable() {
            if (!showSecondLaw || sectorPoints.length < 2) return;
            
            const table = document.getElementById('areaMeasurements');
            // Limpar linhas anteriores exceto o cabeçalho
            while (table.rows.length > 1) {
                table.deleteRow(1);
            }
            
            // Adicionar dados de cada setor
            for (let i = 0; i < sectorPoints.length - 1; i++) {
                const startPoint = sectorPoints[i];
                const endPoint = sectorPoints[i + 1];
                
                // Calcular a área do setor triangular
                const dx1 = startPoint.x - starX;
                const dy1 = startPoint.y - starY;
                const dx2 = endPoint.x - starX;
                const dy2 = endPoint.y - starY;
                const area = Math.abs(dx1 * dy2 - dx2 * dy1) / 2;
                
                const timeDiff = ((endPoint.time - startPoint.time) / 1000).toFixed(1);
                const velocity = (Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + 
                                           Math.pow(endPoint.y - startPoint.y, 2)) / parseFloat(timeDiff)).toFixed(1);
                
                const sectorColors = ["#FFB74D", "#64B5F6", "#F06292"];
                
                const row = table.insertRow();
                row.innerHTML = `
                    <td>
                        <div class="equal-area-indicator" style="background-color: ${sectorColors[i]}"></div>
                        Setor ${i + 1}
                    </td>
                    <td>${(area).toFixed(0)} u²</td>
                    <td>${timeDiff} s</td>
                    <td>${velocity} u/s</td>
                `;
            }
        }
        
        // Iniciar simulação quando a página carregar
        window.onload = function() {
            generateStars(100); // Gerar 100 estrelas
            startSimulation();
            const infoElement = document.querySelector('.info');
            console.log('Altura da caixa de informações:', infoElement.offsetHeight + 'px');
        };
    </script>

    <!-- Footer com Créditos -->
    <footer class="footer">
        <div class="credits">
            <h3>Créditos</h3>
            <div class="credits-content">
                <div class="credit-item">
                    <h4>Desenvolvimento</h4>
                    <p>Felipe Augusto Gomes de Morais</p>
                    <p>Projetos Integrados em Física</p>
                </div>
                <div class="credit-item">
                    <h4>Orientação</h4>
                    <p>Prof. Celso Duarte</p>
                    <p>Departamento de Física - UFPR</p>
                </div>
                <div class="credit-item">
                    <h4>Instituição</h4>
                    <p>Universidade Federal do Paraná</p>
                    <p>UFPR</p>
                </div>
                <div class="credit-item">
                    <h4>Tecnologias Utilizadas</h4>
                    <p>HTML5, CSS3, JavaScript</p>
                    <p>Canvas API</p>
                </div>
            </div>
            <p>© 2024 - Todos os direitos reservados</p>
        </div>
    </footer>
</body>
</html>