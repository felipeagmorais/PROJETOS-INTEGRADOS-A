<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Experimentos - Leis de Kepler</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&family=Space+Grotesk:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0a192f 0%, #162744 100%);
            color: #e6e6e6;
        }

        .navigation {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .nav-button {
            background: rgba(100, 255, 218, 0.1);
            border: 1px solid rgba(100, 255, 218, 0.3);
            color: #64ffda;
            padding: 10px 20px;
            border-radius: 5px;
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .experiments-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .experiment-header {
            text-align: center;
            margin-bottom: 40px;
        }

        .experiment-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            justify-content: center;
        }

        .tab-button {
            padding: 15px 30px;
            background: rgba(100, 255, 218, 0.1);
            border: none;
            color: #64ffda;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
        }

        .tab-button.active {
            background: rgba(100, 255, 218, 0.2);
            transform: translateY(-5px);
        }

        .experiment-content {
            display: none;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            background: rgba(255, 255, 255, 0.05);
            padding: 30px;
            border-radius: 15px;
            min-height: 700px; /* Aumentado de 600px para 700px */
        }

        .experiment-content.active {
            display: grid;
        }

        .experiment-sidebar {
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-radius: 10px;
            height: fit-content;
        }

        .experiment-main {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .canvas-container {
            flex: 1;
            min-height: 600px; /* Aumentado de 500px para 600px */
            position: relative;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            overflow: hidden;
        }

        .canvas-container canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .slider-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .slider-container input[type="range"] {
            -webkit-appearance: none;
            width: 300px;
            height: 6px;
            background: rgba(100, 255, 218, 0.1);
            border-radius: 3px;
            outline: none;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #64ffda;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .parameter-box {
            background: rgba(255, 255, 255, 0.05);
            border-left: 4px solid #64ffda;
            padding: 15px 20px;
            margin: 8px;
            min-width: 140px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            border-radius: 8px;
        }

        .physics-info {
            position: absolute;
            right: 20px;
            bottom: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(100, 255, 218, 0.2);
            backdrop-filter: blur(5px);
        }

        .instructions {
            background: rgba(100, 255, 218, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .main-formula {
            text-align: center;
            font-size: 24px;
            color: #64ffda;
            padding: 15px;
            background: rgba(100, 255, 218, 0.05);
            border-radius: 8px;
            margin: 10px 0;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .parameters {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            margin: 15px auto;
            max-width: 600px;
        }

        .planet-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 20px;
        }

        .planet-btn {
            background: rgba(100, 255, 218, 0.1);
            border: 1px solid rgba(100, 255, 218, 0.3);
            color: #64ffda;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .planet-btn:hover {
            background: rgba(100, 255, 218, 0.2);
            transform: translateY(-2px);
        }

        .planet-btn.active {
            background: rgba(100, 255, 218, 0.3);
            border-color: #64ffda;
        }

        .planet-info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .planet-info .parameter-box {
            margin: 8px 0;
            padding: 10px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="navigation">
        <a href="historia.html" class="nav-button">← Voltar ao Início</a>
    </div>

    <div class="experiments-container">
        <div class="experiment-header">
            <h1>Experimentos Interativos - Leis de Kepler</h1>
            <div class="experiment-tabs">
                <button class="tab-button active" onclick="switchExperiment('primeira-lei')">Primeira Lei</button>
                <button class="tab-button" onclick="switchExperiment('segunda-lei')">Segunda Lei</button>
                <button class="tab-button" onclick="switchExperiment('terceira-lei')">Terceira Lei</button>
            </div>
        </div>

        <div id="primeira-lei" class="experiment-content active">
            <div class="experiment-sidebar">
                <div class="instructions">
                    <h3>Primeira Lei de Kepler</h3>
                    <p>Os planetas se movem em órbitas elípticas com o Sol em um dos focos.</p>
                    <p>Ajuste os parâmetros para ver como a forma da órbita muda.</p>
                </div>
                
                <div class="controls">
                    <label for="axis1">Semi-eixo maior (U.A.):</label>
                    <div class="slider-container">
                        <span>0.5</span>
                        <input id="axis1" type="range" min="0.5" max="5" value="1" step="0.1">
                        <span>5.0</span>
                    </div>
                    <div class="parameter-box">
                        <div>Valor atual:</div>
                        <div id="axisValue1">1.0</div>
                    </div>
                    
                    <label for="eccentricity1">Excentricidade:</label>
                    <div class="slider-container">
                        <span>0</span>
                        <input id="eccentricity1" type="range" min="0" max="0.9" value="0.5" step="0.1">
                        <span>0.9</span>
                    </div>
                    <div class="parameter-box">
                        <div>Valor atual:</div>
                        <div id="eccentricityValue1">0.5</div>
                    </div>
                </div>
            </div>

            <div class="experiment-main">
                <div class="canvas-container">
                    <canvas id="ellipse-canvas"></canvas>
                    <div id="physicsInfo1" class="physics-info">
                        <div>Valores Instantâneos</div>
                        <div class="parameter-box">
                            <div>Velocidade:</div>
                            <div id="velocityOutput1">0.0 UA/ano</div>
                        </div>
                        <div class="parameter-box">
                            <div>Momento Angular:</div>
                            <div id="angularMomentumOutput1">0.0 UA²/ano</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="segunda-lei" class="experiment-content">
            <div class="experiment-sidebar">
                <div class="instructions">
                    <h3>Segunda Lei de Kepler</h3>
                    <p>Os planetas varrem áreas iguais em tempos iguais.</p>
                </div>
                
                <div class="controls">
                    <label for="axis2">Semi-eixo maior (U.A.):</label>
                    <div class="slider-container">
                        <span>0.5</span>
                        <input id="axis2" type="range" min="0.5" max="5" value="1" step="0.1">
                        <span>5.0</span>
                    </div>
                    <div class="parameter-box">
                        <div>Valor atual:</div>
                        <div id="axisValue2">1.0</div>
                    </div>
                    
                    <label for="eccentricity2">Excentricidade:</label>
                    <div class="slider-container">
                        <span>0</span>
                        <input id="eccentricity2" type="range" min="0" max="0.9" value="0.5" step="0.1">
                        <span>0.9</span>
                    </div>
                    <div class="parameter-box">
                        <div>Valor atual:</div>
                        <div id="eccentricityValue2">0.5</div>
                    </div>
                </div>
            </div>

            <div class="experiment-main">
                <div class="canvas-container">
                    <canvas id="areas-canvas"></canvas>
                    <div id="areaInfo" class="physics-info">
                        <div>Áreas Varridas</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="terceira-lei" class="experiment-content">
            <div class="experiment-sidebar">
                <div class="instructions">
                    <h3>Terceira Lei de Kepler</h3>
                    <p>O quadrado do período orbital é proporcional ao cubo do semi-eixo maior.</p>
                    <p><strong>Fórmula:</strong> T² = a³ (em unidades astronômicas e anos)</p>
                </div>
                
                <div class="controls">
                    <h4>Planetas do Sistema Solar:</h4>
                    <div class="planet-buttons">
                        <button class="planet-btn" onclick="setPlanet('mercurio')">Mercúrio</button>
                        <button class="planet-btn" onclick="setPlanet('venus')">Vênus</button>
                        <button class="planet-btn" onclick="setPlanet('terra')">Terra</button>
                        <button class="planet-btn" onclick="setPlanet('marte')">Marte</button>
                        <button class="planet-btn" onclick="setPlanet('jupiter')">Júpiter</button>
                        <button class="planet-btn" onclick="setPlanet('saturno')">Saturno</button>
                        <button class="planet-btn" onclick="setPlanet('urano')">Urano</button>
                        <button class="planet-btn" onclick="setPlanet('netuno')">Netuno</button>
                    </div>
                    
                    <label for="axis3">Semi-eixo maior (U.A.):</label>
                    <div class="slider-container">
                        <span>0.4</span>
                        <input id="axis3" type="range" min="0.4" max="30" value="1" step="0.1">
                        <span>30.0</span>
                    </div>
                    <div class="parameter-box">
                        <div>Valor atual:</div>
                        <div id="axisValue3">1.0</div>
                    </div>
                    
                    <div class="planet-info">
                        <div class="parameter-box">
                            <div>Planeta selecionado:</div>
                            <div id="planetName">Terra</div>
                        </div>
                        <div class="parameter-box">
                            <div>Período real:</div>
                            <div id="realPeriod">1.0 anos</div>
                        </div>
                        <div class="parameter-box">
                            <div>Período calculado:</div>
                            <div id="calculatedPeriod">1.0 anos</div>
                        </div>
                        <div class="parameter-box">
                            <div>Diferença:</div>
                            <div id="periodDifference">0.0%</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="experiment-main">
                <div class="canvas-container">
                    <canvas id="period-canvas"></canvas>
                    <div id="periodOutput" class="physics-info">
                        <div>Período Orbital</div>
                    </div>
                </div>
                <div class="main-formula">
                    T² = a³
                </div>
            </div>
        </div>
    </div>

    <script>
        let animationId;
        const stars = [];
        let sectorPoints = [];
        let sectorAreas = [];  // Novo array para armazenar as áreas
        let nextSectorTime = Date.now();
        let showSecondLaw = false;
        let startTime = Date.now();
        let scale = 120; // Aumentado de 60 para 120 para dobrar o tamanho das órbitas

        function generateStars(count, canvas) {
            stars.length = 0;
            for (let i = 0; i < count; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.5 + 0.5,
                    opacity: Math.random() * 0.8 + 0.2
                });
            }
        }

        function drawVector(ctx, startX, startY, endX, endY, color, label) {
            const angle = Math.atan2(endY - startY);
            const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            const headLength = Math.min(15, length * 0.3);
            const headAngle = Math.PI / 6;

            // Desenhar linha principal
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Desenhar ponta da seta
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - headLength * Math.cos(angle - headAngle),
                endY - headLength * Math.sin(angle - headAngle)
            );
            ctx.moveTo(endX, endY);
            ctx.lineTo(
                endX - headLength * Math.cos(angle + headAngle),
                endY - headLength * Math.sin(angle + headAngle)
            );
            ctx.stroke();

            // Adicionar label
            if (label) {
                ctx.fillStyle = color;
                ctx.font = '14px Arial';
                ctx.fillText(label, endX + 5, endY + 5);
            }
        }

        function drawOrbit(ctx, canvas, a, e, showVectors = false) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const b = a * Math.sqrt(1 - e * e);
            const scaledA = a * scale;
            const scaledB = b * scale;
            const c = a * e;
            const scaledC = c * scale;
            
            // Ajustando os focos (agora Sol à direita)
            const rightFocusX = centerX + scaledC; // Sol (foco direito)
            const leftFocusX = centerX - scaledC; // Outro foco

            // Limpar e desenhar fundo
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (const star of stars) {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, 2 * Math.PI);
                ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                ctx.fill();
            }

            // Desenhar órbita elíptica
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.ellipse(centerX, centerY, scaledA, scaledB, 0, 0, 2 * Math.PI);
            ctx.stroke();

            // Desenhar segundo foco (agora à esquerda)
            ctx.beginPath();
            ctx.arc(leftFocusX, centerY, 4, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(255, 100, 100, 0.5)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
            ctx.stroke();

            // Desenhar Sol no foco direito
            ctx.beginPath();
            ctx.arc(rightFocusX, centerY, 8, 0, 2 * Math.PI);
            ctx.fillStyle = 'yellow';
            ctx.fill();

            // Glow do Sol (agora à direita)
            const gradient = ctx.createRadialGradient(
                rightFocusX, centerY, 8,
                rightFocusX, centerY, 16
            );
            gradient.addColorStop(0, 'rgba(255, 255, 150, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 255, 150, 0)');
            ctx.beginPath();
            ctx.arc(rightFocusX, centerY, 16, 0, 2 * Math.PI);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Calcular posição do planeta usando a anomalia excêntrica
            const elapsedTime = (Date.now() - startTime) / 1000;
            const meanMotion = 2 * Math.PI / (a ** 1.5); // Terceira Lei de Kepler
            const meanAnomaly = meanMotion * elapsedTime;
            
            // Resolver a equação de Kepler (E - e*sin(E) = M) usando método iterativo
            let E = meanAnomaly;
            for (let i = 0; i < 5; i++) {
                E = E - (E - e * Math.sin(E) - meanAnomaly) / (1 - e * Math.cos(E));
            }
            
            // Converter anomalia excêntrica para coordenadas cartesianas corretamente
            const cosE = Math.cos(E);
            const sinE = Math.sin(E);
            
            // Coordenadas corrigidas para alinhar com a elipse desenhada
            const x = centerX + scaledA * cosE;
            const y = centerY + scaledB * sinE;

            // Desenhar planeta
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, 2 * Math.PI);
            ctx.fillStyle = '#3498db';
            ctx.fill();

            if (showVectors) {
                const dx = x - rightFocusX;
                const dy = y - centerY;
                const r = Math.sqrt(dx*dx + dy*dy) / scale;
                
                // Calcular momento angular (constante)
                const L = Math.sqrt(a * (1 - e*e));
                const speed = L/r;
                
                // Calcular direção tangente à elipse
                const dx_dt = -scaledA * Math.sin(E);
                const dy_dt = scaledB * Math.cos(E);
                
                // Normalizar o vetor tangente e ajustar comprimento pela velocidade
                const tangentMagnitude = Math.sqrt(dx_dt*dx_dt + dy_dt*dy_dt);
                const velocityScale = 20; // Fator base para escala visual
                const velocityVectorLength = velocityScale * (speed / L * a); // Comprimento proporcional à velocidade
                const velocityEndX = x + velocityVectorLength * (dx_dt / tangentMagnitude);
                const velocityEndY = y + velocityVectorLength * (dy_dt / tangentMagnitude);
                
                // Desenhar vetor velocidade
                drawVector(ctx, x, y, velocityEndX, velocityEndY, '#4CAF50', 'v');
                
                // Vetor força gravitacional
                const forceMagnitude = 5 / (r * r);
                const forceX = -dx / r * forceMagnitude;
                const forceY = -dy / r * forceMagnitude;
                drawVector(ctx, x, y, x + forceX, y + forceY, '#FF4444', 'F');
                
                // Calcular velocidades máxima e mínima
                const vmax = L/(a * (1 - e));
                const vmin = L/(a * (1 + e));
                
                const velocityPercent = ((speed - vmin) / (vmax - vmin) * 100).toFixed(0);
                const arrow = speed > L/a ? '↑' : '↓';
                
                // Atualizar valores instantâneos
                document.getElementById('velocityOutput1').innerHTML = `
                    <div>Atual: ${speed.toFixed(2)} UA/ano ${arrow}</div>
                    <div style="font-size: 0.8em; color: #64ffda">
                        Máx: ${vmax.toFixed(2)} UA/ano<br>
                        Mín: ${vmin.toFixed(2)} UA/ano<br>
                        (${velocityPercent}% do intervalo)
                    </div>
                `;
                
                document.getElementById('angularMomentumOutput1').innerHTML = `
                    <div>${L.toFixed(2)} UA²/ano</div>
                    <div style="font-size: 0.8em; color: #64ffda">(constante)</div>
                `;
            }

            return { centerX, centerY, starX: rightFocusX, scaledA, scaledB, x, y };
        }

        function calculateEllipticalSectorArea(starX, centerY, x1, y1, x2, y2, a, b, e) {
            // Converter para coordenadas relativas ao foco (estrela)
            const dx1 = x1 - starX;
            const dy1 = y1 - centerY;
            const dx2 = x2 - starX;
            const dy2 = y2 - centerY;
            
            // Calcular anomalia verdadeira para cada ponto
            let f1 = Math.atan2(dy1, dx1);
            let f2 = Math.atan2(dy2, dx2);
            
            // Ajustar ângulos para garantir movimento contínuo
            if (f2 < f1) f2 += 2 * Math.PI;
            
            // Usar a constante da área (segunda lei de Kepler)
            const L = Math.sqrt(a * (1 - e*e)); // Momento angular específico
            const mu = 4 * Math.PI * Math.PI; // Parâmetro gravitacional (em UA³/ano²)
            
            // Calcular área usando a constante da área
            const dt = Math.abs(f2 - f1) * a * b / (2 * L);
            const area = 0.5 * L * dt;
            
            return area;
        }

        const mu = 4 * Math.PI * Math.PI; // Parâmetro gravitacional (UA³/ano²)

        function drawOrbitWithAreas(ctx, canvas, a, e, showAreas) {
            // Limpar canvas e desenhar fundo
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Desenhar estrelas de fundo
            for (const star of stars) {
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, 2 * Math.PI);
                ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                ctx.fill();
            }

            const orbitData = drawOrbit(ctx, canvas, a, e, false);
            const currentTime = Date.now();
            const elapsedTime = (currentTime - startTime) / 1000;
            const b = a * Math.sqrt(1 - e * e);

            // Desenhar a órbita
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.ellipse(orbitData.centerX, orbitData.centerY, orbitData.scaledA, orbitData.scaledB, 0, 0, 2 * Math.PI);
            ctx.stroke();

            // Desenhar Sol
            ctx.beginPath();
            ctx.arc(orbitData.starX, orbitData.centerY, 8, 0, 2 * Math.PI);
            ctx.fillStyle = 'yellow';
            ctx.fill();

            // Glow do Sol
            const gradient = ctx.createRadialGradient(
                orbitData.starX, orbitData.centerY, 8,
                orbitData.starX, orbitData.centerY, 16
            );
            gradient.addColorStop(0, 'rgba(255, 255, 150, 0.8)');
            gradient.addColorStop(1, 'rgba(255, 255, 150, 0)');
            ctx.beginPath();
            ctx.arc(orbitData.starX, orbitData.centerY, 16, 0, 2 * Math.PI);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Calcular parâmetros necessários
            const dx = orbitData.x - orbitData.starX;
            const dy = orbitData.y - orbitData.centerY;
            const r = Math.sqrt(dx*dx + dy*dy) / scale;
            const L = Math.sqrt(a * (1 - e*e));

            // Sistema de setores de tempo igual
            if (!sectorPoints) sectorPoints = [];
            if (!sectorAreas) sectorAreas = [];
            
            // Adicionar novo ponto a cada intervalo
            if (Math.floor(elapsedTime * 2) > Math.floor((lastElapsedTime || 0) * 2)) {
                sectorPoints.push({
                    x: orbitData.x,
                    y: orbitData.y,
                    time: currentTime,
                    v: L/r
                });
                
                if (sectorPoints.length > 1) {
                    const area = L * 0.25; // Área varrida em meio segundo
                    sectorAreas.push(area);
                }
                
                // Limitar número de setores
                if (sectorPoints.length > 8) {
                    sectorPoints.shift();
                    sectorAreas.shift();
                }
            }

            // Desenhar todos os setores acumulados
            sectorPoints.forEach((point, i) => {
                if (i < sectorPoints.length - 1) {
                    ctx.beginPath();
                    ctx.moveTo(orbitData.starX, orbitData.centerY);
                    
                    // Calcular ângulos inicial e final para o arco
                    const angle1 = Math.atan2(point.y - orbitData.centerY, point.x - orbitData.centerX);
                    const angle2 = Math.atan2(sectorPoints[i+1].y - orbitData.centerY, 
                                            sectorPoints[i+1].x - orbitData.centerX);
                    
                    // Salvar contexto para aplicar transformação
                    ctx.save();
                    ctx.translate(orbitData.centerX, orbitData.centerY);
                    ctx.scale(orbitData.scaledA/orbitData.scaledB, 1);
                    
                    // Desenhar o arco elíptico
                    ctx.arc(0, 0, orbitData.scaledB, angle1, angle2, false);
                    
                    // Restaurar contexto
                    ctx.restore();
                    
                    ctx.lineTo(orbitData.starX, orbitData.centerY);
                    ctx.closePath();
                    
                    // Cor baseada na velocidade (vermelho=rápido, azul=lento)
                    const v = point.v;
                    const vmax = L/(a*(1-e));
                    const vmin = L/(a*(1+e));
                    const t = (v - vmin)/(vmax - vmin);
                    ctx.fillStyle = `rgba(${255*t}, 100, ${255*(1-t)}, 0.3)`;
                    ctx.fill();
                    
                    // Mostrar área do setor
                    const centerX = (point.x + sectorPoints[i+1].x)/2;
                    const centerY = (point.y + sectorPoints[i+1].y)/2;
                    ctx.font = '12px Poppins';
                    ctx.fillStyle = '#ffffff';
                    ctx.textAlign = 'center';
                    ctx.fillText(`${sectorAreas[i].toFixed(3)} UA²`, centerX, centerY);
                }
            });
            
            // Mostrar informações didáticas
            document.getElementById('areaInfo').innerHTML = `
                <div style="font-weight: bold; margin-bottom: 10px;">
                    Segunda Lei de Kepler
                </div>
                <div class="parameter-box">
                    <div>Área por segundo:</div>
                    <div>${(L/2).toFixed(3)} UA²/s</div>
                    <div style="font-size: 0.8em; color: #64ffda">(constante)</div>
                </div>
                <div class="parameter-box">
                    <div>Velocidade atual:</div>
                    <div>${(L/Math.sqrt(dx*dx + dy*dy)).toFixed(2)} UA/ano</div>
                    <div style="font-size: 0.8em; color: #64ffda">
                        ${sectorPoints.length > 0 ? '✓ Área constante' : 'Aguardando...'}
                    </div>
                </div>
            `;
            
            lastElapsedTime = elapsedTime;

            // Depois de desenhar os setores, desenhar o planeta
            ctx.beginPath();
            ctx.arc(orbitData.x, orbitData.y, 6, 0, 2 * Math.PI);
            ctx.fillStyle = '#3498db';
            ctx.fill();
        }

        let currentE = 0; // Variável global para rastrear a última posição

        function drawOrbitWithPeriod(ctx, canvas, a, e, T) {
            const orbitData = drawOrbit(ctx, canvas, a, e, false); // false para não mostrar vetores
            
            // Mostrar informação do período
            ctx.fillStyle = '#64ffda';
            ctx.font = '16px Poppins';
            ctx.fillText(`Período: ${T.toFixed(2)} anos`, 20, 30);
            ctx.fillText(`Semi-eixo maior: ${a.toFixed(2)} UA`, 20, 60);
        }

        function setupEllipseExperiment() {
            const canvas = document.getElementById('ellipse-canvas');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            const ctx = canvas.getContext('2d');
            generateStars(100, canvas);
            startTime = Date.now(); // Resetar o tempo inicial
            
            const axis1 = document.getElementById('axis1');
            const ecc1 = document.getElementById('eccentricity1');
            const axisValue1 = document.getElementById('axisValue1');
            const eccValue1 = document.getElementById('eccentricityValue1');
            
            axis1.addEventListener('input', function() {
                axisValue1.textContent = parseFloat(this.value).toFixed(1);
            });
            
            ecc1.addEventListener('input', function() {
                eccValue1.textContent = parseFloat(this.value).toFixed(1);
            });
            
            function animate() {
                const a = parseFloat(axis1.value);
                const e = parseFloat(ecc1.value);
                drawOrbit(ctx, canvas, a, e, true);
                animationId = requestAnimationFrame(animate);
            }
            
            animate(); // Iniciar a animação
        }

        function setupAreasExperiment() {
            const canvas = document.getElementById('areas-canvas');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            const ctx = canvas.getContext('2d');
            generateStars(100, canvas);
            startTime = Date.now();
            sectorPoints = [];
            sectorAreas = [];
            lastElapsedTime = 0;
            
            const axis2 = document.getElementById('axis2');
            const ecc2 = document.getElementById('eccentricity2');
            const axisValue2 = document.getElementById('axisValue2');
            const eccValue2 = document.getElementById('eccentricityValue2');
            
            axis2.addEventListener('input', function() {
                axisValue2.textContent = parseFloat(this.value).toFixed(1);
                startTime = Date.now(); // Resetar ao mudar parâmetros
                sectorPoints = [];
                sectorAreas = [];
            });
            
            ecc2.addEventListener('input', function() {
                eccValue2.textContent = parseFloat(this.value).toFixed(1);
                startTime = Date.now(); // Resetar ao mudar parâmetros
                sectorPoints = [];
                sectorAreas = [];
            });
            
            function animate() {
                const a = parseFloat(axis2.value);
                const e = parseFloat(ecc2.value);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawOrbitWithAreas(ctx, canvas, a, e, true);
                animationId = requestAnimationFrame(animate);
            }
            
            animate();
        }

        // Dados dos planetas do Sistema Solar
        const planetsData = {
            mercurio: { name: 'Mercúrio', distance: 0.39, period: 0.24, color: '#8C7853' },
            venus: { name: 'Vênus', distance: 0.72, period: 0.62, color: '#FFC649' },
            terra: { name: 'Terra', distance: 1.00, period: 1.00, color: '#6B93D6' },
            marte: { name: 'Marte', distance: 1.52, period: 1.88, color: '#CD5C5C' },
            jupiter: { name: 'Júpiter', distance: 5.20, period: 11.86, color: '#D8CA9D' },
            saturno: { name: 'Saturno', distance: 9.54, period: 29.46, color: '#FAD5A5' },
            urano: { name: 'Urano', distance: 19.19, period: 84.01, color: '#4FD0E7' },
            netuno: { name: 'Netuno', distance: 30.07, period: 164.8, color: '#4B70DD' }
        };

        let currentPlanet = 'terra';

        function setPlanet(planetKey) {
            currentPlanet = planetKey;
            const planet = planetsData[planetKey];
            
            // Atualizar o slider
            const axis3 = document.getElementById('axis3');
            axis3.value = planet.distance;
            document.getElementById('axisValue3').textContent = planet.distance.toFixed(2);
            
            // Atualizar informações do planeta
            document.getElementById('planetName').textContent = planet.name;
            document.getElementById('realPeriod').textContent = `${planet.period.toFixed(2)} anos`;
            
            // Calcular período usando a terceira lei
            const calculatedPeriod = Math.sqrt(Math.pow(planet.distance, 3));
            document.getElementById('calculatedPeriod').textContent = `${calculatedPeriod.toFixed(2)} anos`;
            
            // Calcular diferença percentual
            const difference = Math.abs((calculatedPeriod - planet.period) / planet.period * 100);
            document.getElementById('periodDifference').textContent = `${difference.toFixed(1)}%`;
            
            // Atualizar botões ativos
            document.querySelectorAll('.planet-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[onclick="setPlanet('${planetKey}')"]`).classList.add('active');
        }

        function setupPeriodExperiment() {
            const canvas = document.getElementById('period-canvas');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            const ctx = canvas.getContext('2d');
            generateStars(100, canvas);
            
            // Configurar listeners para o slider
            const axis3 = document.getElementById('axis3');
            const axisValue3 = document.getElementById('axisValue3');
            
            axis3.addEventListener('input', function() {
                const a = parseFloat(this.value);
                axisValue3.textContent = a.toFixed(2);
                
                // Atualizar cálculos
                const calculatedPeriod = Math.sqrt(Math.pow(a, 3));
                document.getElementById('calculatedPeriod').textContent = `${calculatedPeriod.toFixed(2)} anos`;
                
                // Se há um planeta selecionado, calcular diferença
                if (currentPlanet) {
                    const planet = planetsData[currentPlanet];
                    const difference = Math.abs((calculatedPeriod - planet.period) / planet.period * 100);
                    document.getElementById('periodDifference').textContent = `${difference.toFixed(1)}%`;
                }
            });
            
            // Inicializar com a Terra
            setPlanet('terra');
            
            function animate() {
                const a = parseFloat(axis3.value);
                const T = Math.sqrt(a ** 3);
                const planet = planetsData[currentPlanet];
                
                // Limpar canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Desenhar estrelas de fundo
                for (const star of stars) {
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, star.radius, 0, 2 * Math.PI);
                    ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`;
                    ctx.fill();
                }
                
                // Desenhar órbita
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const maxRadius = Math.min(canvas.width, canvas.height) / 2.5; // Aumentado de /3 para /2.5
                const orbitRadius = Math.min((a / 10) * maxRadius, maxRadius * 0.9); // Melhor escala para planetas próximos
                
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.arc(centerX, centerY, orbitRadius, 0, 2 * Math.PI);
                ctx.stroke();
                
                // Desenhar Sol
                ctx.beginPath();
                ctx.arc(centerX, centerY, 8, 0, 2 * Math.PI);
                ctx.fillStyle = 'yellow';
                ctx.fill();
                
                // Glow do Sol
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, 8,
                    centerX, centerY, 16
                );
                gradient.addColorStop(0, 'rgba(255, 255, 150, 0.8)');
                gradient.addColorStop(1, 'rgba(255, 255, 150, 0)');
                ctx.beginPath();
                ctx.arc(centerX, centerY, 16, 0, 2 * Math.PI);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Desenhar planeta com cor específica
                const elapsedTime = (Date.now() - startTime) / 1000;
                const angle = (elapsedTime / T) * 2 * Math.PI;
                const planetX = centerX + orbitRadius * Math.cos(angle);
                const planetY = centerY + orbitRadius * Math.sin(angle);
                
                ctx.beginPath();
                ctx.arc(planetX, planetY, 6, 0, 2 * Math.PI);
                ctx.fillStyle = planet.color;
                ctx.fill();
                
                // Informações na tela
                ctx.fillStyle = '#64ffda';
                ctx.font = '16px Poppins';
                ctx.fillText(`${planet.name}`, 20, 30);
                ctx.fillText(`Distância: ${a.toFixed(2)} UA`, 20, 55);
                ctx.fillText(`Período: ${T.toFixed(2)} anos`, 20, 80);
                
                // Mostrar comparação se não for o valor real
                if (Math.abs(a - planet.distance) > 0.1) {
                    ctx.fillStyle = '#ff6b6b';
                    ctx.font = '14px Poppins';
                    ctx.fillText(`Real: ${planet.distance} UA, ${planet.period.toFixed(2)} anos`, 20, 105);
                }
                
                document.getElementById('periodOutput').innerHTML = `
                    <div>Período calculado:</div>
                    <div>${T.toFixed(2)} anos</div>
                    <div style="font-size: 0.8em; margin-top: 5px;">
                        T² = ${T.toFixed(2)}² = ${(T*T).toFixed(1)}<br>
                        a³ = ${a.toFixed(2)}³ = ${(a*a*a).toFixed(1)}
                    </div>
                `;
                
                animationId = requestAnimationFrame(animate);
            }
            
            animate();
        }

        function switchExperiment(id) {
            cancelAnimationFrame(animationId);
            startTime = Date.now(); // Resetar o tempo ao trocar de experimento
            document.querySelectorAll('.experiment-content').forEach(exp => {
                exp.classList.remove('active');
            });
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            document.getElementById(id).classList.add('active');
            document.querySelector(`[onclick="switchExperiment('${id}')"]`).classList.add('active');

            switch(id) {
                case 'primeira-lei':
                    setupEllipseExperiment();
                    break;
                case 'segunda-lei':
                    setupAreasExperiment();
                    break;
                case 'terceira-lei':
                    setupPeriodExperiment();
                    break;
            }
        }

        window.onload = () => {
            setupEllipseExperiment();
        };
    </script>
</body>
</html>
